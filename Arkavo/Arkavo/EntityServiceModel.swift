// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Arkavo_ActivityLevel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unused = 0
  case low = 1
  case medium = 2
  case high = 3

  public static var max: Arkavo_ActivityLevel { return .high }
  public static var min: Arkavo_ActivityLevel { return .unused }
}


public enum Arkavo_MediaType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unused = 0
  case text = 1
  case image = 2
  case video = 3
  case audio = 4

  public static var max: Arkavo_MediaType { return .audio }
  public static var min: Arkavo_MediaType { return .unused }
}


public enum Arkavo_LocationLevel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unused = 0
  case wide = 1
  case approximate = 2
  case precise = 3

  public static var max: Arkavo_LocationLevel { return .precise }
  public static var min: Arkavo_LocationLevel { return .unused }
}


public enum Arkavo_IdentityAssuranceLevel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unused = 0
  case ial0 = 1
  case ial1 = 2
  case ial2 = 3
  case ial25 = 4
  case ial3 = 5

  public static var max: Arkavo_IdentityAssuranceLevel { return .ial3 }
  public static var min: Arkavo_IdentityAssuranceLevel { return .unused }
}


public enum Arkavo_EncryptionLevel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unused = 0
  case el0 = 1
  case el1 = 2
  case el2 = 3

  public static var max: Arkavo_EncryptionLevel { return .el2 }
  public static var min: Arkavo_EncryptionLevel { return .unused }
}


public enum Arkavo_StreamLevel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unused = 0
  case sl0 = 1
  case sl1 = 2
  case sl2 = 3

  public static var max: Arkavo_StreamLevel { return .sl2 }
  public static var min: Arkavo_StreamLevel { return .unused }
}


public enum Arkavo_ExpertLevel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unused = 0
  case novice = 1
  case intermediate = 2
  case expert = 3
  case master = 4

  public static var max: Arkavo_ExpertLevel { return .master }
  public static var min: Arkavo_ExpertLevel { return .unused }
}


public enum Arkavo_TrustLevel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unused = 0
  case untrusted = 1
  case low = 2
  case medium = 3
  case high = 4
  case verified = 5

  public static var max: Arkavo_TrustLevel { return .verified }
  public static var min: Arkavo_TrustLevel { return .unused }
}


public enum Arkavo_Entity: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case account = 1
  case stream = 2
  case thought = 3

  public static var max: Arkavo_Entity { return .thought }
  public static var min: Arkavo_Entity { return .none_ }
}


public struct Arkavo_PublicId: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasId: Bool { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? false : true }
  public var idCount: Int32 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func id(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var id: [UInt8] { return _accessor.getVector(at: VTOFFSET.id.v) ?? [] }
  public static func startPublicId(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func endPublicId(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPublicId(
    _ fbb: inout FlatBufferBuilder,
    idVectorOffset id: Offset = Offset()
  ) -> Offset {
    let __start = Arkavo_PublicId.startPublicId(&fbb)
    Arkavo_PublicId.addVectorOf(id: id, &fbb)
    return Arkavo_PublicId.endPublicId(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

public struct Arkavo_Account: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case publicId = 4
    case profile = 6
    case activity = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var publicId: Arkavo_PublicId? { let o = _accessor.offset(VTOFFSET.publicId.v); return o == 0 ? nil : Arkavo_PublicId(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var profile: Arkavo_Profile? { let o = _accessor.offset(VTOFFSET.profile.v); return o == 0 ? nil : Arkavo_Profile(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var activity: Arkavo_Activity? { let o = _accessor.offset(VTOFFSET.activity.v); return o == 0 ? nil : Arkavo_Activity(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public static func startAccount(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(publicId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: publicId, at: VTOFFSET.publicId.p) }
  public static func add(profile: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: profile, at: VTOFFSET.profile.p) }
  public static func add(activity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: activity, at: VTOFFSET.activity.p) }
  public static func endAccount(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAccount(
    _ fbb: inout FlatBufferBuilder,
    publicIdOffset publicId: Offset = Offset(),
    profileOffset profile: Offset = Offset(),
    activityOffset activity: Offset = Offset()
  ) -> Offset {
    let __start = Arkavo_Account.startAccount(&fbb)
    Arkavo_Account.add(publicId: publicId, &fbb)
    Arkavo_Account.add(profile: profile, &fbb)
    Arkavo_Account.add(activity: activity, &fbb)
    return Arkavo_Account.endAccount(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.publicId.p, fieldName: "publicId", required: false, type: ForwardOffset<Arkavo_PublicId>.self)
    try _v.visit(field: VTOFFSET.profile.p, fieldName: "profile", required: false, type: ForwardOffset<Arkavo_Profile>.self)
    try _v.visit(field: VTOFFSET.activity.p, fieldName: "activity", required: false, type: ForwardOffset<Arkavo_Activity>.self)
    _v.finish()
  }
}

public struct Arkavo_Stream: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case publicId = 4
    case profile = 6
    case activity = 8
    case creatorPublicId = 10
    case membersPublicId = 12
    case streamLevel = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var publicId: Arkavo_PublicId? { let o = _accessor.offset(VTOFFSET.publicId.v); return o == 0 ? nil : Arkavo_PublicId(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var profile: Arkavo_Profile? { let o = _accessor.offset(VTOFFSET.profile.v); return o == 0 ? nil : Arkavo_Profile(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var activity: Arkavo_Activity? { let o = _accessor.offset(VTOFFSET.activity.v); return o == 0 ? nil : Arkavo_Activity(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var creatorPublicId: Arkavo_PublicId? { let o = _accessor.offset(VTOFFSET.creatorPublicId.v); return o == 0 ? nil : Arkavo_PublicId(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var hasMembersPublicId: Bool { let o = _accessor.offset(VTOFFSET.membersPublicId.v); return o == 0 ? false : true }
  public var membersPublicIdCount: Int32 { let o = _accessor.offset(VTOFFSET.membersPublicId.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func membersPublicId(at index: Int32) -> Arkavo_PublicId? { let o = _accessor.offset(VTOFFSET.membersPublicId.v); return o == 0 ? nil : Arkavo_PublicId(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var streamLevel: Arkavo_StreamLevel { let o = _accessor.offset(VTOFFSET.streamLevel.v); return o == 0 ? .unused : Arkavo_StreamLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public static func startStream(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(publicId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: publicId, at: VTOFFSET.publicId.p) }
  public static func add(profile: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: profile, at: VTOFFSET.profile.p) }
  public static func add(activity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: activity, at: VTOFFSET.activity.p) }
  public static func add(creatorPublicId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: creatorPublicId, at: VTOFFSET.creatorPublicId.p) }
  public static func addVectorOf(membersPublicId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: membersPublicId, at: VTOFFSET.membersPublicId.p) }
  public static func add(streamLevel: Arkavo_StreamLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: streamLevel.rawValue, def: 0, at: VTOFFSET.streamLevel.p) }
  public static func endStream(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStream(
    _ fbb: inout FlatBufferBuilder,
    publicIdOffset publicId: Offset = Offset(),
    profileOffset profile: Offset = Offset(),
    activityOffset activity: Offset = Offset(),
    creatorPublicIdOffset creatorPublicId: Offset = Offset(),
    membersPublicIdVectorOffset membersPublicId: Offset = Offset(),
    streamLevel: Arkavo_StreamLevel = .unused
  ) -> Offset {
    let __start = Arkavo_Stream.startStream(&fbb)
    Arkavo_Stream.add(publicId: publicId, &fbb)
    Arkavo_Stream.add(profile: profile, &fbb)
    Arkavo_Stream.add(activity: activity, &fbb)
    Arkavo_Stream.add(creatorPublicId: creatorPublicId, &fbb)
    Arkavo_Stream.addVectorOf(membersPublicId: membersPublicId, &fbb)
    Arkavo_Stream.add(streamLevel: streamLevel, &fbb)
    return Arkavo_Stream.endStream(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.publicId.p, fieldName: "publicId", required: false, type: ForwardOffset<Arkavo_PublicId>.self)
    try _v.visit(field: VTOFFSET.profile.p, fieldName: "profile", required: false, type: ForwardOffset<Arkavo_Profile>.self)
    try _v.visit(field: VTOFFSET.activity.p, fieldName: "activity", required: false, type: ForwardOffset<Arkavo_Activity>.self)
    try _v.visit(field: VTOFFSET.creatorPublicId.p, fieldName: "creatorPublicId", required: false, type: ForwardOffset<Arkavo_PublicId>.self)
    try _v.visit(field: VTOFFSET.membersPublicId.p, fieldName: "membersPublicId", required: false, type: ForwardOffset<Vector<ForwardOffset<Arkavo_PublicId>, Arkavo_PublicId>>.self)
    try _v.visit(field: VTOFFSET.streamLevel.p, fieldName: "streamLevel", required: false, type: Arkavo_StreamLevel.self)
    _v.finish()
  }
}

public struct Arkavo_Thought: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case publicId = 4
    case creatorPublicId = 6
    case streamPublicId = 8
    case content = 10
    case mediaType = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var publicId: Arkavo_PublicId? { let o = _accessor.offset(VTOFFSET.publicId.v); return o == 0 ? nil : Arkavo_PublicId(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var creatorPublicId: Arkavo_PublicId? { let o = _accessor.offset(VTOFFSET.creatorPublicId.v); return o == 0 ? nil : Arkavo_PublicId(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var streamPublicId: Arkavo_PublicId? { let o = _accessor.offset(VTOFFSET.streamPublicId.v); return o == 0 ? nil : Arkavo_PublicId(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var hasContent: Bool { let o = _accessor.offset(VTOFFSET.content.v); return o == 0 ? false : true }
  public var contentCount: Int32 { let o = _accessor.offset(VTOFFSET.content.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func content(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.content.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var content: [UInt8] { return _accessor.getVector(at: VTOFFSET.content.v) ?? [] }
  public var mediaType: Arkavo_MediaType { let o = _accessor.offset(VTOFFSET.mediaType.v); return o == 0 ? .unused : Arkavo_MediaType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public static func startThought(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(publicId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: publicId, at: VTOFFSET.publicId.p) }
  public static func add(creatorPublicId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: creatorPublicId, at: VTOFFSET.creatorPublicId.p) }
  public static func add(streamPublicId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: streamPublicId, at: VTOFFSET.streamPublicId.p) }
  public static func addVectorOf(content: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: content, at: VTOFFSET.content.p) }
  public static func add(mediaType: Arkavo_MediaType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mediaType.rawValue, def: 0, at: VTOFFSET.mediaType.p) }
  public static func endThought(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createThought(
    _ fbb: inout FlatBufferBuilder,
    publicIdOffset publicId: Offset = Offset(),
    creatorPublicIdOffset creatorPublicId: Offset = Offset(),
    streamPublicIdOffset streamPublicId: Offset = Offset(),
    contentVectorOffset content: Offset = Offset(),
    mediaType: Arkavo_MediaType = .unused
  ) -> Offset {
    let __start = Arkavo_Thought.startThought(&fbb)
    Arkavo_Thought.add(publicId: publicId, &fbb)
    Arkavo_Thought.add(creatorPublicId: creatorPublicId, &fbb)
    Arkavo_Thought.add(streamPublicId: streamPublicId, &fbb)
    Arkavo_Thought.addVectorOf(content: content, &fbb)
    Arkavo_Thought.add(mediaType: mediaType, &fbb)
    return Arkavo_Thought.endThought(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.publicId.p, fieldName: "publicId", required: false, type: ForwardOffset<Arkavo_PublicId>.self)
    try _v.visit(field: VTOFFSET.creatorPublicId.p, fieldName: "creatorPublicId", required: false, type: ForwardOffset<Arkavo_PublicId>.self)
    try _v.visit(field: VTOFFSET.streamPublicId.p, fieldName: "streamPublicId", required: false, type: ForwardOffset<Arkavo_PublicId>.self)
    try _v.visit(field: VTOFFSET.content.p, fieldName: "content", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.mediaType.p, fieldName: "mediaType", required: false, type: Arkavo_MediaType.self)
    _v.finish()
  }
}

public struct Arkavo_Profile: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    case blurb = 6
    case interests = 8
    case location = 10
    case locationLevel = 12
    case identityAssuranceLevel = 14
    case encryptionLevel = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var blurb: String? { let o = _accessor.offset(VTOFFSET.blurb.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var blurbSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.blurb.v) }
  public var interests: String? { let o = _accessor.offset(VTOFFSET.interests.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var interestsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.interests.v) }
  public var location: String? { let o = _accessor.offset(VTOFFSET.location.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var locationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.location.v) }
  public var locationLevel: Arkavo_LocationLevel { let o = _accessor.offset(VTOFFSET.locationLevel.v); return o == 0 ? .unused : Arkavo_LocationLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var identityAssuranceLevel: Arkavo_IdentityAssuranceLevel { let o = _accessor.offset(VTOFFSET.identityAssuranceLevel.v); return o == 0 ? .unused : Arkavo_IdentityAssuranceLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var encryptionLevel: Arkavo_EncryptionLevel { let o = _accessor.offset(VTOFFSET.encryptionLevel.v); return o == 0 ? .unused : Arkavo_EncryptionLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public static func startProfile(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(blurb: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: blurb, at: VTOFFSET.blurb.p) }
  public static func add(interests: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: interests, at: VTOFFSET.interests.p) }
  public static func add(location: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: location, at: VTOFFSET.location.p) }
  public static func add(locationLevel: Arkavo_LocationLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: locationLevel.rawValue, def: 0, at: VTOFFSET.locationLevel.p) }
  public static func add(identityAssuranceLevel: Arkavo_IdentityAssuranceLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: identityAssuranceLevel.rawValue, def: 0, at: VTOFFSET.identityAssuranceLevel.p) }
  public static func add(encryptionLevel: Arkavo_EncryptionLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptionLevel.rawValue, def: 0, at: VTOFFSET.encryptionLevel.p) }
  public static func endProfile(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createProfile(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset = Offset(),
    blurbOffset blurb: Offset = Offset(),
    interestsOffset interests: Offset = Offset(),
    locationOffset location: Offset = Offset(),
    locationLevel: Arkavo_LocationLevel = .unused,
    identityAssuranceLevel: Arkavo_IdentityAssuranceLevel = .unused,
    encryptionLevel: Arkavo_EncryptionLevel = .unused
  ) -> Offset {
    let __start = Arkavo_Profile.startProfile(&fbb)
    Arkavo_Profile.add(name: name, &fbb)
    Arkavo_Profile.add(blurb: blurb, &fbb)
    Arkavo_Profile.add(interests: interests, &fbb)
    Arkavo_Profile.add(location: location, &fbb)
    Arkavo_Profile.add(locationLevel: locationLevel, &fbb)
    Arkavo_Profile.add(identityAssuranceLevel: identityAssuranceLevel, &fbb)
    Arkavo_Profile.add(encryptionLevel: encryptionLevel, &fbb)
    return Arkavo_Profile.endProfile(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.blurb.p, fieldName: "blurb", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.interests.p, fieldName: "interests", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.location.p, fieldName: "location", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.locationLevel.p, fieldName: "locationLevel", required: false, type: Arkavo_LocationLevel.self)
    try _v.visit(field: VTOFFSET.identityAssuranceLevel.p, fieldName: "identityAssuranceLevel", required: false, type: Arkavo_IdentityAssuranceLevel.self)
    try _v.visit(field: VTOFFSET.encryptionLevel.p, fieldName: "encryptionLevel", required: false, type: Arkavo_EncryptionLevel.self)
    _v.finish()
  }
}

public struct Arkavo_Activity: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case dateCreated = 4
    case expertLevel = 6
    case activityLevel = 8
    case trustLevel = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var dateCreated: Int64 { let o = _accessor.offset(VTOFFSET.dateCreated.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var expertLevel: Arkavo_ExpertLevel { let o = _accessor.offset(VTOFFSET.expertLevel.v); return o == 0 ? .unused : Arkavo_ExpertLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var activityLevel: Arkavo_ActivityLevel { let o = _accessor.offset(VTOFFSET.activityLevel.v); return o == 0 ? .unused : Arkavo_ActivityLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var trustLevel: Arkavo_TrustLevel { let o = _accessor.offset(VTOFFSET.trustLevel.v); return o == 0 ? .unused : Arkavo_TrustLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public static func startActivity(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(dateCreated: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dateCreated, def: 0, at: VTOFFSET.dateCreated.p) }
  public static func add(expertLevel: Arkavo_ExpertLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: expertLevel.rawValue, def: 0, at: VTOFFSET.expertLevel.p) }
  public static func add(activityLevel: Arkavo_ActivityLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: activityLevel.rawValue, def: 0, at: VTOFFSET.activityLevel.p) }
  public static func add(trustLevel: Arkavo_TrustLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trustLevel.rawValue, def: 0, at: VTOFFSET.trustLevel.p) }
  public static func endActivity(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createActivity(
    _ fbb: inout FlatBufferBuilder,
    dateCreated: Int64 = 0,
    expertLevel: Arkavo_ExpertLevel = .unused,
    activityLevel: Arkavo_ActivityLevel = .unused,
    trustLevel: Arkavo_TrustLevel = .unused
  ) -> Offset {
    let __start = Arkavo_Activity.startActivity(&fbb)
    Arkavo_Activity.add(dateCreated: dateCreated, &fbb)
    Arkavo_Activity.add(expertLevel: expertLevel, &fbb)
    Arkavo_Activity.add(activityLevel: activityLevel, &fbb)
    Arkavo_Activity.add(trustLevel: trustLevel, &fbb)
    return Arkavo_Activity.endActivity(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.dateCreated.p, fieldName: "dateCreated", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.expertLevel.p, fieldName: "expertLevel", required: false, type: Arkavo_ExpertLevel.self)
    try _v.visit(field: VTOFFSET.activityLevel.p, fieldName: "activityLevel", required: false, type: Arkavo_ActivityLevel.self)
    try _v.visit(field: VTOFFSET.trustLevel.p, fieldName: "trustLevel", required: false, type: Arkavo_TrustLevel.self)
    _v.finish()
  }
}

public struct Arkavo_EntityRoot: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case entityType = 4
    case entity = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var entityType: Arkavo_Entity { let o = _accessor.offset(VTOFFSET.entityType.v); return o == 0 ? .none_ : Arkavo_Entity(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func entity<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.entity.v); return o == 0 ? nil : _accessor.union(o) }
  public static func startEntityRoot(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(entityType: Arkavo_Entity, _ fbb: inout FlatBufferBuilder) { fbb.add(element: entityType.rawValue, def: 0, at: VTOFFSET.entityType.p) }
  public static func add(entity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: entity, at: VTOFFSET.entity.p) }
  public static func endEntityRoot(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEntityRoot(
    _ fbb: inout FlatBufferBuilder,
    entityType: Arkavo_Entity = .none_,
    entityOffset entity: Offset = Offset()
  ) -> Offset {
    let __start = Arkavo_EntityRoot.startEntityRoot(&fbb)
    Arkavo_EntityRoot.add(entityType: entityType, &fbb)
    Arkavo_EntityRoot.add(entity: entity, &fbb)
    return Arkavo_EntityRoot.endEntityRoot(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(unionKey: VTOFFSET.entityType.p, unionField: VTOFFSET.entity.p, unionKeyName: "entityType", fieldName: "entity", required: false, completion: { (verifier, key: Arkavo_Entity, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .account:
        try ForwardOffset<Arkavo_Account>.verify(&verifier, at: pos, of: Arkavo_Account.self)
      case .stream:
        try ForwardOffset<Arkavo_Stream>.verify(&verifier, at: pos, of: Arkavo_Stream.self)
      case .thought:
        try ForwardOffset<Arkavo_Thought>.verify(&verifier, at: pos, of: Arkavo_Thought.self)
      }
    })
    _v.finish()
  }
}

