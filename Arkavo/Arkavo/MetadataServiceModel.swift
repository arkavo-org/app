// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Arkavo_RatingLevel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unused = 0
  case none_ = 1
  case mild = 2
  case moderate = 3
  case severe = 4

  public static var max: Arkavo_RatingLevel { return .severe }
  public static var min: Arkavo_RatingLevel { return .unused }
}


public enum Arkavo_FormatType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case plain = 0
  case html = 1
  case csv = 2
  case xml = 3
  case json = 4
  case jpeg = 10
  case png = 11
  case svg = 12
  case gif = 13
  case pdf = 30

  public static var max: Arkavo_FormatType { return .pdf }
  public static var min: Arkavo_FormatType { return .plain }
}


public enum Arkavo_DataEncoding: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case binary = 0
  case utf8 = 1
  case utf16 = 2
  case ascii = 3
  case base64 = 4
  case quotedPrintable = 5

  public static var max: Arkavo_DataEncoding { return .quotedPrintable }
  public static var min: Arkavo_DataEncoding { return .binary }
}


public enum Arkavo_ArchiveType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case zip = 1
  case tar = 2
  case gzip = 3
  case bzip2 = 4
  case xz = 5
  case zstd = 6
  case lz4 = 7

  public static var max: Arkavo_ArchiveType { return .lz4 }
  public static var min: Arkavo_ArchiveType { return .none_ }
}


public struct Arkavo_Rating: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case violent = 4
    case sexual = 6
    case profane = 8
    case substance = 10
    case hate = 12
    case harm = 14
    case mature = 16
    case bully = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var violent: Arkavo_RatingLevel { let o = _accessor.offset(VTOFFSET.violent.v); return o == 0 ? .unused : Arkavo_RatingLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var sexual: Arkavo_RatingLevel { let o = _accessor.offset(VTOFFSET.sexual.v); return o == 0 ? .unused : Arkavo_RatingLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var profane: Arkavo_RatingLevel { let o = _accessor.offset(VTOFFSET.profane.v); return o == 0 ? .unused : Arkavo_RatingLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var substance: Arkavo_RatingLevel { let o = _accessor.offset(VTOFFSET.substance.v); return o == 0 ? .unused : Arkavo_RatingLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var hate: Arkavo_RatingLevel { let o = _accessor.offset(VTOFFSET.hate.v); return o == 0 ? .unused : Arkavo_RatingLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var harm: Arkavo_RatingLevel { let o = _accessor.offset(VTOFFSET.harm.v); return o == 0 ? .unused : Arkavo_RatingLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var mature: Arkavo_RatingLevel { let o = _accessor.offset(VTOFFSET.mature.v); return o == 0 ? .unused : Arkavo_RatingLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var bully: Arkavo_RatingLevel { let o = _accessor.offset(VTOFFSET.bully.v); return o == 0 ? .unused : Arkavo_RatingLevel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public static func startRating(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(violent: Arkavo_RatingLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: violent.rawValue, def: 0, at: VTOFFSET.violent.p) }
  public static func add(sexual: Arkavo_RatingLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sexual.rawValue, def: 0, at: VTOFFSET.sexual.p) }
  public static func add(profane: Arkavo_RatingLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: profane.rawValue, def: 0, at: VTOFFSET.profane.p) }
  public static func add(substance: Arkavo_RatingLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: substance.rawValue, def: 0, at: VTOFFSET.substance.p) }
  public static func add(hate: Arkavo_RatingLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hate.rawValue, def: 0, at: VTOFFSET.hate.p) }
  public static func add(harm: Arkavo_RatingLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: harm.rawValue, def: 0, at: VTOFFSET.harm.p) }
  public static func add(mature: Arkavo_RatingLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mature.rawValue, def: 0, at: VTOFFSET.mature.p) }
  public static func add(bully: Arkavo_RatingLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bully.rawValue, def: 0, at: VTOFFSET.bully.p) }
  public static func endRating(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRating(
    _ fbb: inout FlatBufferBuilder,
    violent: Arkavo_RatingLevel = .unused,
    sexual: Arkavo_RatingLevel = .unused,
    profane: Arkavo_RatingLevel = .unused,
    substance: Arkavo_RatingLevel = .unused,
    hate: Arkavo_RatingLevel = .unused,
    harm: Arkavo_RatingLevel = .unused,
    mature: Arkavo_RatingLevel = .unused,
    bully: Arkavo_RatingLevel = .unused
  ) -> Offset {
    let __start = Arkavo_Rating.startRating(&fbb)
    Arkavo_Rating.add(violent: violent, &fbb)
    Arkavo_Rating.add(sexual: sexual, &fbb)
    Arkavo_Rating.add(profane: profane, &fbb)
    Arkavo_Rating.add(substance: substance, &fbb)
    Arkavo_Rating.add(hate: hate, &fbb)
    Arkavo_Rating.add(harm: harm, &fbb)
    Arkavo_Rating.add(mature: mature, &fbb)
    Arkavo_Rating.add(bully: bully, &fbb)
    return Arkavo_Rating.endRating(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.violent.p, fieldName: "violent", required: false, type: Arkavo_RatingLevel.self)
    try _v.visit(field: VTOFFSET.sexual.p, fieldName: "sexual", required: false, type: Arkavo_RatingLevel.self)
    try _v.visit(field: VTOFFSET.profane.p, fieldName: "profane", required: false, type: Arkavo_RatingLevel.self)
    try _v.visit(field: VTOFFSET.substance.p, fieldName: "substance", required: false, type: Arkavo_RatingLevel.self)
    try _v.visit(field: VTOFFSET.hate.p, fieldName: "hate", required: false, type: Arkavo_RatingLevel.self)
    try _v.visit(field: VTOFFSET.harm.p, fieldName: "harm", required: false, type: Arkavo_RatingLevel.self)
    try _v.visit(field: VTOFFSET.mature.p, fieldName: "mature", required: false, type: Arkavo_RatingLevel.self)
    try _v.visit(field: VTOFFSET.bully.p, fieldName: "bully", required: false, type: Arkavo_RatingLevel.self)
    _v.finish()
  }
}

public struct Arkavo_Purpose: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case educational = 4
    case entertainment = 6
    case news = 8
    case promotional = 10
    case personal = 12
    case opinion = 14
    case transactional = 16
    case harmful = 18
    case confidence = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var educational: Float32 { let o = _accessor.offset(VTOFFSET.educational.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var entertainment: Float32 { let o = _accessor.offset(VTOFFSET.entertainment.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var news: Float32 { let o = _accessor.offset(VTOFFSET.news.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var promotional: Float32 { let o = _accessor.offset(VTOFFSET.promotional.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var personal: Float32 { let o = _accessor.offset(VTOFFSET.personal.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var opinion: Float32 { let o = _accessor.offset(VTOFFSET.opinion.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var transactional: Float32 { let o = _accessor.offset(VTOFFSET.transactional.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var harmful: Float32 { let o = _accessor.offset(VTOFFSET.harmful.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var confidence: Float32 { let o = _accessor.offset(VTOFFSET.confidence.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public static func startPurpose(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(educational: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: educational, def: 0.0, at: VTOFFSET.educational.p) }
  public static func add(entertainment: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: entertainment, def: 0.0, at: VTOFFSET.entertainment.p) }
  public static func add(news: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: news, def: 0.0, at: VTOFFSET.news.p) }
  public static func add(promotional: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: promotional, def: 0.0, at: VTOFFSET.promotional.p) }
  public static func add(personal: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: personal, def: 0.0, at: VTOFFSET.personal.p) }
  public static func add(opinion: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: opinion, def: 0.0, at: VTOFFSET.opinion.p) }
  public static func add(transactional: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: transactional, def: 0.0, at: VTOFFSET.transactional.p) }
  public static func add(harmful: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: harmful, def: 0.0, at: VTOFFSET.harmful.p) }
  public static func add(confidence: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: confidence, def: 0.0, at: VTOFFSET.confidence.p) }
  public static func endPurpose(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPurpose(
    _ fbb: inout FlatBufferBuilder,
    educational: Float32 = 0.0,
    entertainment: Float32 = 0.0,
    news: Float32 = 0.0,
    promotional: Float32 = 0.0,
    personal: Float32 = 0.0,
    opinion: Float32 = 0.0,
    transactional: Float32 = 0.0,
    harmful: Float32 = 0.0,
    confidence: Float32 = 0.0
  ) -> Offset {
    let __start = Arkavo_Purpose.startPurpose(&fbb)
    Arkavo_Purpose.add(educational: educational, &fbb)
    Arkavo_Purpose.add(entertainment: entertainment, &fbb)
    Arkavo_Purpose.add(news: news, &fbb)
    Arkavo_Purpose.add(promotional: promotional, &fbb)
    Arkavo_Purpose.add(personal: personal, &fbb)
    Arkavo_Purpose.add(opinion: opinion, &fbb)
    Arkavo_Purpose.add(transactional: transactional, &fbb)
    Arkavo_Purpose.add(harmful: harmful, &fbb)
    Arkavo_Purpose.add(confidence: confidence, &fbb)
    return Arkavo_Purpose.endPurpose(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.educational.p, fieldName: "educational", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.entertainment.p, fieldName: "entertainment", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.news.p, fieldName: "news", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.promotional.p, fieldName: "promotional", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.personal.p, fieldName: "personal", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.opinion.p, fieldName: "opinion", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.transactional.p, fieldName: "transactional", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.harmful.p, fieldName: "harmful", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.confidence.p, fieldName: "confidence", required: false, type: Float32.self)
    _v.finish()
  }
}

public struct Arkavo_FormatInfo: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    case version = 6
    case profile = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var type: Arkavo_FormatType { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? .plain : Arkavo_FormatType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .plain }
  public var version: String? { let o = _accessor.offset(VTOFFSET.version.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var versionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.version.v) }
  public var profile: String? { let o = _accessor.offset(VTOFFSET.profile.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var profileSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.profile.v) }
  public static func startFormatInfo(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(type: Arkavo_FormatType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: VTOFFSET.type.p) }
  public static func add(version: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: version, at: VTOFFSET.version.p) }
  public static func add(profile: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: profile, at: VTOFFSET.profile.p) }
  public static func endFormatInfo(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFormatInfo(
    _ fbb: inout FlatBufferBuilder,
    type: Arkavo_FormatType = .plain,
    versionOffset version: Offset = Offset(),
    profileOffset profile: Offset = Offset()
  ) -> Offset {
    let __start = Arkavo_FormatInfo.startFormatInfo(&fbb)
    Arkavo_FormatInfo.add(type: type, &fbb)
    Arkavo_FormatInfo.add(version: version, &fbb)
    Arkavo_FormatInfo.add(profile: profile, &fbb)
    return Arkavo_FormatInfo.endFormatInfo(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: Arkavo_FormatType.self)
    try _v.visit(field: VTOFFSET.version.p, fieldName: "version", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.profile.p, fieldName: "profile", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Arkavo_ArchiveInfo: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    case version = 6
    case profile = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var type: Arkavo_ArchiveType { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? .none_ : Arkavo_ArchiveType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var version: String? { let o = _accessor.offset(VTOFFSET.version.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var versionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.version.v) }
  public var profile: String? { let o = _accessor.offset(VTOFFSET.profile.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var profileSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.profile.v) }
  public static func startArchiveInfo(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(type: Arkavo_ArchiveType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: VTOFFSET.type.p) }
  public static func add(version: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: version, at: VTOFFSET.version.p) }
  public static func add(profile: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: profile, at: VTOFFSET.profile.p) }
  public static func endArchiveInfo(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArchiveInfo(
    _ fbb: inout FlatBufferBuilder,
    type: Arkavo_ArchiveType = .none_,
    versionOffset version: Offset = Offset(),
    profileOffset profile: Offset = Offset()
  ) -> Offset {
    let __start = Arkavo_ArchiveInfo.startArchiveInfo(&fbb)
    Arkavo_ArchiveInfo.add(type: type, &fbb)
    Arkavo_ArchiveInfo.add(version: version, &fbb)
    Arkavo_ArchiveInfo.add(profile: profile, &fbb)
    return Arkavo_ArchiveInfo.endArchiveInfo(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: Arkavo_ArchiveType.self)
    try _v.visit(field: VTOFFSET.version.p, fieldName: "version", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.profile.p, fieldName: "profile", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Arkavo_ContentFormat: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case mediaType = 4
    case dataEncoding = 6
    case format = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var mediaType: Arkavo_MediaType { let o = _accessor.offset(VTOFFSET.mediaType.v); return o == 0 ? .unused : Arkavo_MediaType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unused }
  public var dataEncoding: Arkavo_DataEncoding { let o = _accessor.offset(VTOFFSET.dataEncoding.v); return o == 0 ? .binary : Arkavo_DataEncoding(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .binary }
  public var format: Arkavo_FormatInfo? { let o = _accessor.offset(VTOFFSET.format.v); return o == 0 ? nil : Arkavo_FormatInfo(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public static func startContentFormat(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(mediaType: Arkavo_MediaType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mediaType.rawValue, def: 0, at: VTOFFSET.mediaType.p) }
  public static func add(dataEncoding: Arkavo_DataEncoding, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataEncoding.rawValue, def: 0, at: VTOFFSET.dataEncoding.p) }
  public static func add(format: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: format, at: VTOFFSET.format.p) }
  public static func endContentFormat(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createContentFormat(
    _ fbb: inout FlatBufferBuilder,
    mediaType: Arkavo_MediaType = .unused,
    dataEncoding: Arkavo_DataEncoding = .binary,
    formatOffset format: Offset = Offset()
  ) -> Offset {
    let __start = Arkavo_ContentFormat.startContentFormat(&fbb)
    Arkavo_ContentFormat.add(mediaType: mediaType, &fbb)
    Arkavo_ContentFormat.add(dataEncoding: dataEncoding, &fbb)
    Arkavo_ContentFormat.add(format: format, &fbb)
    return Arkavo_ContentFormat.endContentFormat(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.mediaType.p, fieldName: "mediaType", required: false, type: Arkavo_MediaType.self)
    try _v.visit(field: VTOFFSET.dataEncoding.p, fieldName: "dataEncoding", required: false, type: Arkavo_DataEncoding.self)
    try _v.visit(field: VTOFFSET.format.p, fieldName: "format", required: false, type: ForwardOffset<Arkavo_FormatInfo>.self)
    _v.finish()
  }
}

public struct Arkavo_Metadata: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_12_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case created = 4
    case id = 6
    case related = 8
    case rating = 10
    case purpose = 12
    case topics = 14
    case archive = 16
    case content = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var created: Int64 { let o = _accessor.offset(VTOFFSET.created.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var hasId: Bool { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? false : true }
  public var idCount: Int32 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func id(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var id: [UInt8] { return _accessor.getVector(at: VTOFFSET.id.v) ?? [] }
  public var hasRelated: Bool { let o = _accessor.offset(VTOFFSET.related.v); return o == 0 ? false : true }
  public var relatedCount: Int32 { let o = _accessor.offset(VTOFFSET.related.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func related(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.related.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var related: [UInt8] { return _accessor.getVector(at: VTOFFSET.related.v) ?? [] }
  public var rating: Arkavo_Rating? { let o = _accessor.offset(VTOFFSET.rating.v); return o == 0 ? nil : Arkavo_Rating(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var purpose: Arkavo_Purpose? { let o = _accessor.offset(VTOFFSET.purpose.v); return o == 0 ? nil : Arkavo_Purpose(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var hasTopics: Bool { let o = _accessor.offset(VTOFFSET.topics.v); return o == 0 ? false : true }
  public var topicsCount: Int32 { let o = _accessor.offset(VTOFFSET.topics.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func topics(at index: Int32) -> UInt32 { let o = _accessor.offset(VTOFFSET.topics.v); return o == 0 ? 0 : _accessor.directRead(of: UInt32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var topics: [UInt32] { return _accessor.getVector(at: VTOFFSET.topics.v) ?? [] }
  public var archive: Arkavo_ArchiveInfo? { let o = _accessor.offset(VTOFFSET.archive.v); return o == 0 ? nil : Arkavo_ArchiveInfo(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var content: Arkavo_ContentFormat? { let o = _accessor.offset(VTOFFSET.content.v); return o == 0 ? nil : Arkavo_ContentFormat(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public static func startMetadata(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(created: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: created, def: 0, at: VTOFFSET.created.p) }
  public static func addVectorOf(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func addVectorOf(related: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: related, at: VTOFFSET.related.p) }
  public static func add(rating: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rating, at: VTOFFSET.rating.p) }
  public static func add(purpose: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: purpose, at: VTOFFSET.purpose.p) }
  public static func addVectorOf(topics: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: topics, at: VTOFFSET.topics.p) }
  public static func add(archive: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: archive, at: VTOFFSET.archive.p) }
  public static func add(content: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: content, at: VTOFFSET.content.p) }
  public static func endMetadata(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMetadata(
    _ fbb: inout FlatBufferBuilder,
    created: Int64 = 0,
    idVectorOffset id: Offset = Offset(),
    relatedVectorOffset related: Offset = Offset(),
    ratingOffset rating: Offset = Offset(),
    purposeOffset purpose: Offset = Offset(),
    topicsVectorOffset topics: Offset = Offset(),
    archiveOffset archive: Offset = Offset(),
    contentOffset content: Offset = Offset()
  ) -> Offset {
    let __start = Arkavo_Metadata.startMetadata(&fbb)
    Arkavo_Metadata.add(created: created, &fbb)
    Arkavo_Metadata.addVectorOf(id: id, &fbb)
    Arkavo_Metadata.addVectorOf(related: related, &fbb)
    Arkavo_Metadata.add(rating: rating, &fbb)
    Arkavo_Metadata.add(purpose: purpose, &fbb)
    Arkavo_Metadata.addVectorOf(topics: topics, &fbb)
    Arkavo_Metadata.add(archive: archive, &fbb)
    Arkavo_Metadata.add(content: content, &fbb)
    return Arkavo_Metadata.endMetadata(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.created.p, fieldName: "created", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.related.p, fieldName: "related", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.rating.p, fieldName: "rating", required: false, type: ForwardOffset<Arkavo_Rating>.self)
    try _v.visit(field: VTOFFSET.purpose.p, fieldName: "purpose", required: false, type: ForwardOffset<Arkavo_Purpose>.self)
    try _v.visit(field: VTOFFSET.topics.p, fieldName: "topics", required: false, type: ForwardOffset<Vector<UInt32, UInt32>>.self)
    try _v.visit(field: VTOFFSET.archive.p, fieldName: "archive", required: false, type: ForwardOffset<Arkavo_ArchiveInfo>.self)
    try _v.visit(field: VTOFFSET.content.p, fieldName: "content", required: false, type: ForwardOffset<Arkavo_ContentFormat>.self)
    _v.finish()
  }
}

