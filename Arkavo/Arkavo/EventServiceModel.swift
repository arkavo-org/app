// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Arkavo_ActionType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case join = 0
  case apply = 1
  case approve = 2
  case leave = 3
  case sendMessage = 4

  public static var max: Arkavo_ActionType { return .sendMessage }
  public static var min: Arkavo_ActionType { return .join }
}


public enum Arkavo_ActionStatus: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case preparing = 0
  case fulfilling = 1
  case fulfilled = 2
  case failed = 3

  public static var max: Arkavo_ActionStatus { return .failed }
  public static var min: Arkavo_ActionStatus { return .preparing }
}


public enum Arkavo_EntityType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case streamProfile = 0
  case accountProfile = 1

  public static var max: Arkavo_EntityType { return .accountProfile }
  public static var min: Arkavo_EntityType { return .streamProfile }
}


public struct Arkavo_Event: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case actionType = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var actionType: Arkavo_ActionType { let o = _accessor.offset(VTOFFSET.actionType.v); return o == 0 ? .join : Arkavo_ActionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .join }
  public static func startEvent(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(actionType: Arkavo_ActionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: actionType.rawValue, def: 0, at: VTOFFSET.actionType.p) }
  public static func endEvent(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEvent(
    _ fbb: inout FlatBufferBuilder,
    actionType: Arkavo_ActionType = .join
  ) -> Offset {
    let __start = Arkavo_Event.startEvent(&fbb)
    Arkavo_Event.add(actionType: actionType, &fbb)
    return Arkavo_Event.endEvent(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.actionType.p, fieldName: "actionType", required: false, type: Arkavo_ActionType.self)
    _v.finish()
  }
}

public struct Arkavo_UserEvent: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case sourceType = 4
    case targetType = 6
    case sourceId = 8
    case targetId = 10
    case timestamp = 12
    case status = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var sourceType: Arkavo_EntityType { let o = _accessor.offset(VTOFFSET.sourceType.v); return o == 0 ? .streamProfile : Arkavo_EntityType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .streamProfile }
  public var targetType: Arkavo_EntityType { let o = _accessor.offset(VTOFFSET.targetType.v); return o == 0 ? .streamProfile : Arkavo_EntityType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .streamProfile }
  public var hasSourceId: Bool { let o = _accessor.offset(VTOFFSET.sourceId.v); return o == 0 ? false : true }
  public var sourceIdCount: Int32 { let o = _accessor.offset(VTOFFSET.sourceId.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func sourceId(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.sourceId.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var sourceId: [UInt8] { return _accessor.getVector(at: VTOFFSET.sourceId.v) ?? [] }
  public var hasTargetId: Bool { let o = _accessor.offset(VTOFFSET.targetId.v); return o == 0 ? false : true }
  public var targetIdCount: Int32 { let o = _accessor.offset(VTOFFSET.targetId.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func targetId(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.targetId.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var targetId: [UInt8] { return _accessor.getVector(at: VTOFFSET.targetId.v) ?? [] }
  public var timestamp: UInt64 { let o = _accessor.offset(VTOFFSET.timestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var status: Arkavo_ActionStatus { let o = _accessor.offset(VTOFFSET.status.v); return o == 0 ? .preparing : Arkavo_ActionStatus(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .preparing }
  public static func startUserEvent(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(sourceType: Arkavo_EntityType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sourceType.rawValue, def: 0, at: VTOFFSET.sourceType.p) }
  public static func add(targetType: Arkavo_EntityType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: targetType.rawValue, def: 0, at: VTOFFSET.targetType.p) }
  public static func addVectorOf(sourceId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceId, at: VTOFFSET.sourceId.p) }
  public static func addVectorOf(targetId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: targetId, at: VTOFFSET.targetId.p) }
  public static func add(timestamp: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timestamp, def: 0, at: VTOFFSET.timestamp.p) }
  public static func add(status: Arkavo_ActionStatus, _ fbb: inout FlatBufferBuilder) { fbb.add(element: status.rawValue, def: 0, at: VTOFFSET.status.p) }
  public static func endUserEvent(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUserEvent(
    _ fbb: inout FlatBufferBuilder,
    sourceType: Arkavo_EntityType = .streamProfile,
    targetType: Arkavo_EntityType = .streamProfile,
    sourceIdVectorOffset sourceId: Offset = Offset(),
    targetIdVectorOffset targetId: Offset = Offset(),
    timestamp: UInt64 = 0,
    status: Arkavo_ActionStatus = .preparing
  ) -> Offset {
    let __start = Arkavo_UserEvent.startUserEvent(&fbb)
    Arkavo_UserEvent.add(sourceType: sourceType, &fbb)
    Arkavo_UserEvent.add(targetType: targetType, &fbb)
    Arkavo_UserEvent.addVectorOf(sourceId: sourceId, &fbb)
    Arkavo_UserEvent.addVectorOf(targetId: targetId, &fbb)
    Arkavo_UserEvent.add(timestamp: timestamp, &fbb)
    Arkavo_UserEvent.add(status: status, &fbb)
    return Arkavo_UserEvent.endUserEvent(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.sourceType.p, fieldName: "sourceType", required: false, type: Arkavo_EntityType.self)
    try _v.visit(field: VTOFFSET.targetType.p, fieldName: "targetType", required: false, type: Arkavo_EntityType.self)
    try _v.visit(field: VTOFFSET.sourceId.p, fieldName: "sourceId", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.targetId.p, fieldName: "targetId", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.timestamp.p, fieldName: "timestamp", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.status.p, fieldName: "status", required: false, type: Arkavo_ActionStatus.self)
    _v.finish()
  }
}

